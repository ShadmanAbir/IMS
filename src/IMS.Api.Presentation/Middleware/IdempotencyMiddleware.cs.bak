using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Caching.Memory;

namespace IMS.Api.Presentation.Middleware;

/// <summary>
/// Middleware for handling idempotent requests to prevent duplicate operations
/// </summary>
public class IdempotencyMiddleware
{
    private readonly RequestDelegate _next;
    private readonly IMemoryCache _cache;
    private readonly ILogger<IdempotencyMiddleware> _logger;
    private readonly TimeSpan _cacheExpiration = TimeSpan.FromMinutes(60); // Cache for 1 hour

    public IdempotencyMiddleware(RequestDelegate next, IMemoryCache cache, ILogger<IdempotencyMiddleware> logger)
    {
        _next = next;
        _cache = cache;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        // Only handle idempotency for write operations
        if (!ShouldHandleIdempotency(context))
        {
            await _next(context);
            return;
        }

        var idempotencyKey = GetIdempotencyKey(context);
        if (string.IsNullOrEmpty(idempotencyKey))
        {
            await _next(context);
            return;
        }

        var cacheKey = GenerateCacheKey(context, idempotencyKey);

        // Check if we have a cached response
        if (_cache.TryGetValue(cacheKey, out var cachedResponse) && cachedResponse is CachedIdempotentResponse cached)
        {
            _logger.LogInformation("Returning cached response for idempotency key: {IdempotencyKey}", idempotencyKey);
            
            context.Response.StatusCode = cached.StatusCode;
            context.Response.ContentType = cached.ContentType;
            
            foreach (var header in cached.Headers)
            {
                context.Response.Headers[header.Key] = header.Value;
            }

            if (!string.IsNullOrEmpty(cached.Body))
            {
                await context.Response.WriteAsync(cached.Body);
            }
            return;
        }

        // Capture the response
        var originalBodyStream = context.Response.Body;
        using var responseBodyStream = new MemoryStream();
        context.Response.Body = responseBodyStream;

        await _next(context);

        // Cache the response if it's a successful write operation
        if (ShouldCacheResponse(context))
        {
            var responseBody = await GetResponseBodyAsync(responseBodyStream);
            
            var responseToCache = new CachedIdempotentResponse
            {
                StatusCode = context.Response.StatusCode,
                ContentType = context.Response.ContentType ?? "application/json",
                Body = responseBody,
                Headers = context.Response.Headers.ToDictionary(h => h.Key, h => h.Value.ToString()),
                CachedAtUtc = DateTime.UtcNow
            };

            _cache.Set(cacheKey, responseToCache, _cacheExpiration);
            _logger.LogInformation("Cached response for idempotency key: {IdempotencyKey}", idempotencyKey);
        }

        // Copy the response back to the original stream
        responseBodyStream.Seek(0, SeekOrigin.Begin);
        await responseBodyStream.CopyToAsync(originalBodyStream);
    }

    private static bool ShouldHandleIdempotency(HttpContext context)
    {
        var method = context.Request.Method;
        return method == "POST" || method == "PUT" || method == "PATCH";
    }

    private static string? GetIdempotencyKey(HttpContext context)
    {
        // Check for idempotency key in headers
        if (context.Request.Headers.TryGetValue("Idempotency-Key", out var headerValue))
        {
            return headerValue.FirstOrDefault();
        }

        // Check for idempotency key in query parameters
        if (context.Request.Query.TryGetValue("idempotencyKey", out var queryValue))
        {
            return queryValue.FirstOrDefault();
        }

        return null;
    }

    private static string GenerateCacheKey(HttpContext context, string idempotencyKey)
    {
        var keyBuilder = new StringBuilder();
        keyBuilder.Append("idempotency:");
        keyBuilder.Append(context.Request.Method);
        keyBuilder.Append(":");
        keyBuilder.Append(context.Request.Path);
        keyBuilder.Append(":");
        
        // Include user ID if available for tenant isolation
        var userIdClaim = context.User?.FindFirst("sub") ?? context.User?.FindFirst("userId");
        if (userIdClaim != null)
        {
            keyBuilder.Append(userIdClaim.Value);
            keyBuilder.Append(":");
        }
        
        keyBuilder.Append(idempotencyKey);

        // Hash the key to ensure consistent length
        using var sha256 = SHA256.Create();
        var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(keyBuilder.ToString()));
        return Convert.ToBase64String(hashBytes);
    }

    private static bool ShouldCacheResponse(HttpContext context)
    {
        // Only cache successful responses (2xx status codes)
        return context.Response.StatusCode >= 200 && context.Response.StatusCode < 300;
    }

    private static async Task<string> GetResponseBodyAsync(MemoryStream responseBodyStream)
    {
        responseBodyStream.Seek(0, SeekOrigin.Begin);
        using var reader = new StreamReader(responseBodyStream, leaveOpen: true);
        return await reader.ReadToEndAsync();
    }
}

/// <summary>
/// Cached response for idempotent operations
/// </summary>
public class CachedIdempotentResponse
{
    public int StatusCode { get; set; }
    public string ContentType { get; set; } = string.Empty;
    public string Body { get; set; } = string.Empty;
    public Dictionary<string, string> Headers { get; set; } = new();
    public DateTime CachedAtUtc { get; set; }
}